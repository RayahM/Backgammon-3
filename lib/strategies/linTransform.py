# Logic for moves generated by using factors generated by simulation

import lib.move as move
import lib.state as state

def playStratCompTurn(state, factors_list):

  posStates = [state]
  move.genAllPossMoves(posStates)

  best = evalStratMove(factors_list, posStates)
  if (best == None):
    print "crashed in playStratCompTurn by returning Null"
    exit()

  return best

def playStratCompTurn(state, factors_list):

  posStates = [state]
  move.genAllPossMoves(posStates)

  best = evalStratMove(factors_list, posStates)
  if (best == None):
    print "crashed in playStratCompTurn by returning Null"
    exit()

  return best


def evalStratMove(factors_list, posStates):

  '''Evaluate all moves in a list and return move with the highest score'''
  cur_max = -1000000
  best_move_state = None

  #copy_posStates = copy.deepcopy(posStates)

  statesToConsider = move.elimInvalidMoves(posStates)

  for x in range(0, len(statesToConsider)):

    #print "evalStratMove" + str(factors_list)
    temp = calcStratMove(statesToConsider[x], factors_list, 0)
    #print temp

    if (temp > cur_max):
      # If temp move better than current best, remove current best and store temp
      cur_max = temp
      best_move_state = statesToConsider[x]


  more_moves = best_move_state.existValidMoves()

  # Reporting bug where a full move is not returned
  if (more_moves == True):
    print "Error - not a final move state"
    print "Possible states to move from"
    for item in posStates:
      print item.existValidMoves()
      item.printState()

    print "Culled list for move calculation"
    for item in statesToConsider:
      print item.existValidMoves()
      item.printState()

    best_move_state.printState()
    exit(1)


  return best_move_state

def calcStratMove(state, fl, print_flag):

  move_value = 0

  turn = state.turn
  ##fl == factors_list

  temp = state.lastOccupiedSpace()
  last_white_space = temp[0]
  last_black_space = temp[1]

  pip_count = state.getPipCount()

  if (state.turn == 0): #white
    if(state.allInFinalQuadrant() == True and last_black_space > last_white_space):
      strat = 2
    else:
      strat = 1
  elif(state.turn == 1): #black
    if(state.allInFinalQuadrant() == True and last_black_space < last_white_space):
      strat = 2
    else:
      strat = 1


  # Score Resets
  white_uncovered_score = 0        #1
  black_uncovered_score = 0
  white_blocade_score = 0
  black_blocade_score = 0          #4

  white_covered_score = 0          #5
  black_covered_score = 0
  white_highest_blocade_count = 0
  black_highest_blocade_count = 0  #8

  # Factors but not scores
  white_blocade_count = 0          #9
  black_blocade_count = 0

  white_blot_points = 0
  black_blot_points = 0            #12


  for x in range(0, 25): # Tun through board for scores
    #White blocade
    if (state.board[x] <= 1):
      if (white_blocade_count > white_highest_blocade_count):
        white_highest_blocade_count = white_blocade_count
      white_blocade_count = 0

    #Black blocade
    if (state.board[x] >= -1): #Non-black space on black's turn
      if (black_blocade_count > black_highest_blocade_count):
        black_highest_blocade_count = black_blocade_count
      black_blocade_count = 0

    # Points for uncovered pieces
    #White uncovered
    if (state.board[x] == 1):
      if(white_blocade_count > white_highest_blocade_count):
        white_highest_blocade_count = white_blocade_count
      white_blocade_count = 0
      if (x > last_black_space):
        if (strat == 1):
          white_blot_points = fl[0] * ((25-x)*fl[1])
        elif (strat == 2):
          white_blot_points = fl[12] * ((25-x)*fl[13])
      white_uncovered_score = white_uncovered_score + white_blot_points

    # Black Uncovered
    if (state.board[x] == -1):
      if(black_blocade_count > black_highest_blocade_count):
        black_highest_blocade_count = black_blocade_count
      black_blocade_count = 0
      if (x < last_white_space):
        black_blot_points = fl[2*strat] * ((x)*fl[3*strat])
      black_uncovered_score = black_uncovered_score + black_blot_points
      #print str(x) + " " + str(black_uncovered_score)

    # Points for blocades
    #White blocades
    if ((state.board[x]) >= 2):
      white_covered_score += 1*fl[4*strat]
      white_blocade_count += 1
      if (white_blocade_count > 1):
        white_blocade_score += white_blocade_count*fl[5*strat]
        #print str(x) + " " + str(white_blocade_count)

    #Black blocades
    if ((state.board[x]) <= -2):
      black_covered_score += 1*fl[6*strat]
      black_blocade_count += 1
      if (black_blocade_count > 1):
        black_blocade_score += black_blocade_count*fl[7*strat]
        #print str(x) + " " + str(white_blocade_count)

  white_points_scored = state.board[0]*fl[strat*8]
  black_points_scored = state.board[25]*fl[strat*10]
  white_jail_score = state.board[26]*fl[strat*9]
  black_jail_score = state.board[27]*fl[strat*11]


  if (state.turn == 1):
    score_tuple = (-1*white_points_scored,
    black_points_scored,
    -1*white_jail_score,
    black_jail_score,
    white_uncovered_score,
    -1*black_uncovered_score,
    -1*white_blocade_score,
    black_blocade_score,
    -1*white_covered_score,
    black_covered_score,
    -1*white_highest_blocade_count,
    black_highest_blocade_count)

  elif (state.turn == 0):
    score_tuple = (white_points_scored,
    -1*black_points_scored,
    white_jail_score,
    -1*black_jail_score,
    -1*white_uncovered_score,
    black_uncovered_score,
    white_blocade_score,
    -1*black_blocade_score,
    white_covered_score,
    -1*black_covered_score,
    white_highest_blocade_count,
    -1*black_highest_blocade_count)

  for x in range(0, len(score_tuple)):
    move_value = move_value + score_tuple[x]*fl[x]

  if (print_flag):
    print "move value: " + str(move_value),
    print "   score_tuple: " + str(score_tuple)
    state.printState()


  return move_value
